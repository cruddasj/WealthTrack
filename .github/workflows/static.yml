# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: write
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    if: github.event_name != 'push' || !startsWith(github.event.head_commit.message || '', 'chore: release v')
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Determine release version
        id: version
        run: |
          latest_tag=$(git tag --list 'v*' --sort=-v:refname | head -n 1)
          if [ -n "$latest_tag" ]; then
            version=${latest_tag#v}
            IFS='.' read -r major minor patch <<< "$version"
            : "${patch:=0}"
          else
            base=$(cat VERSION_BASE 2>/dev/null | tr -d '\r')
            if [ -z "$base" ]; then
              base="1.0"
            fi
            IFS='.' read -r major minor extra <<< "$base"
            if [ -z "$minor" ]; then
              minor=0
            fi
            patch=-1
          fi
          next_patch=$((patch + 1))
          version="$major.$minor.$next_patch"
          echo "version=$version" >> "$GITHUB_OUTPUT"
          echo "tag=v$version" >> "$GITHUB_OUTPUT"
      - name: Update version assets
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          node <<'NODE'
          const fs = require('fs');
          const version = process.env.VERSION;
          if (!version) {
            throw new Error('Missing VERSION');
          }

          fs.writeFileSync('assets/version.json', JSON.stringify({ version }, null, 2) + '\n');

          const swPath = 'service-worker.js';
          const source = fs.readFileSync(swPath, 'utf8');
          const updated = source.replace(/const APP_VERSION = "[^"]*";/, `const APP_VERSION = "${version}";`);
          if (source === updated) {
            throw new Error('Failed to update service worker version constant');
          }
          fs.writeFileSync(swPath, updated);
          NODE
      - name: Commit release artifacts
        id: commit_release
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add assets/version.json service-worker.js
          if git diff --cached --quiet; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            git commit -m "chore: release v${VERSION}"
            git push origin HEAD
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi
      - name: Create tag and release
        if: steps.commit_release.outputs.changed == 'true'
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          release_name: ${{ steps.version.outputs.tag }}
          body: "Automated release for ${{ steps.version.outputs.version }}"
      - name: Prune old releases
        if: steps.commit_release.outputs.changed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const maxReleases = 5;
            const { owner, repo } = context.repo;
            const releases = await github.paginate(
              github.rest.repos.listReleases,
              { owner, repo, per_page: 100 }
            );
            const toDelete = releases
              .filter((release) => !release.draft && !release.prerelease)
              .slice(maxReleases);
            for (const release of toDelete) {
              await github.rest.repos.deleteRelease({
                owner,
                repo,
                release_id: release.id,
              });
              if (release.tag_name) {
                try {
                  await github.rest.git.deleteRef({
                    owner,
                    repo,
                    ref: `tags/${release.tag_name}`,
                  });
                } catch (error) {
                  if (error.status !== 404) throw error;
                }
              }
            }
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - name: Install dependencies
        run: npm ci
      - name: Build icons
        run: npm run build:icons
      - name: Build CSS
        run: npm run build:css
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload entire repository
          path: '.'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
